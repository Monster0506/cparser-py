// Basic C99 Grammar for Lark

?start: translation_unit

translation_unit: external_declaration+

external_declaration: function_definition
                    | declaration

// Functions
function_definition: declaration_specifiers declarator compound_statement

// Declarations
declaration: declaration_specifiers init_declarator_list? ";"
           | static_assert_declaration

static_assert_declaration: "_Static_assert" "(" constant_expression "," string_literal+ ")" ";"

declaration_specifiers: (storage_class_specifier | type_specifier | type_qualifier | function_specifier | gcc_attribute_specifier | alignment_specifier)+

alignment_specifier: ("_Alignas" | "alignas") "(" (type_name | constant_expression) ")"

storage_class_specifier: "typedef" | "extern" | "static" | "auto" | "register"

gcc_attribute_specifier: "__attribute__" "((" argument_expression_list? "))"

type_specifier: "void" | "char" | "short" | "int" | "long" | "float" | "double" | "signed" | "unsigned" | "_Bool" | "_Complex"
              | atomic_type_specifier
              | struct_or_union_specifier
              | enum_specifier
              | typedef_name

atomic_type_specifier: "_Atomic" "(" type_name ")"

type_qualifier: "const" | "restrict" | "volatile" | "_Atomic"

function_specifier: "inline"

init_declarator_list: init_declarator ("," init_declarator)*

init_declarator: declarator
               | declarator "=" initializer

// Structs/Unions
struct_or_union_specifier: struct_or_union identifier? "{" struct_declaration_list "}"
                         | struct_or_union identifier

struct_or_union: "struct" | "union"

struct_declaration_list: struct_declaration+

struct_declaration: specifier_qualifier_list struct_declarator_list? ";"

specifier_qualifier_list: (type_specifier | type_qualifier)+

struct_declarator_list: struct_declarator ("," struct_declarator)*

struct_declarator: declarator
                 | declarator? ":" constant_expression

// Enums
enum_specifier: "enum" identifier? "{" enumerator_list "}"
              | "enum" identifier? "{" enumerator_list "," "}"
              | "enum" identifier

enumerator_list: enumerator ("," enumerator)*

enumerator: enumeration_constant
          | enumeration_constant "=" constant_expression

enumeration_constant: identifier

// Declarators
declarator: pointer? direct_declarator

direct_declarator: identifier
                 | "(" declarator ")"
                 | direct_declarator "[" type_qualifier_list? assignment_expression? "]"
                 | direct_declarator "[" "static" type_qualifier_list? assignment_expression "]"
                 | direct_declarator "[" type_qualifier_list "static" assignment_expression "]"
                 | direct_declarator "[" type_qualifier_list? "*" "]"
                 | direct_declarator "(" parameter_type_list ")"
                 | direct_declarator "(" identifier_list? ")"

pointer: "*" type_qualifier_list? pointer?

type_qualifier_list: type_qualifier+

parameter_type_list: parameter_list
                   | parameter_list "," "..."

parameter_list: parameter_declaration ("," parameter_declaration)*

parameter_declaration: declaration_specifiers declarator
                     | declaration_specifiers abstract_declarator?

identifier_list: identifier ("," identifier)*

type_name: specifier_qualifier_list abstract_declarator?

abstract_declarator: pointer
                   | pointer? direct_abstract_declarator

direct_abstract_declarator: "(" abstract_declarator ")"
                          | direct_abstract_declarator? "[" assignment_expression? "]"
                          | direct_abstract_declarator? "[" "*" "]"
                          | direct_abstract_declarator? "(" parameter_type_list? ")"

// Initializers
initializer: assignment_expression
           | "{" initializer_list "}"
           | "{" initializer_list "," "}"

initializer_list: initializer ("," initializer)*
                | designation initializer ("," designation initializer)*

designation: designator_list "="

designator_list: designator+

designator: "[" constant_expression "]"
          | "." identifier

// Statements
statement: labeled_statement
         | compound_statement
         | expression_statement
         | selection_statement
         | iteration_statement
         | jump_statement

labeled_statement: identifier ":" statement
                 | "case" constant_expression ":" statement
                 | "default" ":" statement

compound_statement: "{" block_item_list? "}"

block_item_list: block_item+

block_item: declaration
          | statement

expression_statement: expression? ";"

selection_statement: "if" "(" expression ")" statement
                   | "if" "(" expression ")" statement "else" statement
                   | "switch" "(" expression ")" statement

iteration_statement: "while" "(" expression ")" statement
                   | "do" statement "while" "(" expression ")" ";"
                   | "for" "(" expression_statement expression_statement expression? ")" statement
                   | "for" "(" declaration expression_statement expression? ")" statement

jump_statement: "goto" identifier ";"
              | "continue" ";"
              | "break" ";"
              | "return" expression? ";"

// Expressions
expression: assignment_expression ("," assignment_expression)*

assignment_expression: conditional_expression
                     | unary_expression assignment_operator assignment_expression

assignment_operator: "=" | "*=" | "/=" | "%=" | "+=" | "-=" | "<<=" | ">>=" | "&=" | "^=" | "|="

conditional_expression: logical_or_expression
                      | logical_or_expression "?" expression ":" conditional_expression

logical_or_expression: logical_and_expression
                     | logical_or_expression "||" logical_and_expression

logical_and_expression: inclusive_or_expression
                      | logical_and_expression "&&" inclusive_or_expression

inclusive_or_expression: exclusive_or_expression
                       | inclusive_or_expression "|" exclusive_or_expression

exclusive_or_expression: and_expression
                       | exclusive_or_expression "^" and_expression

and_expression: equality_expression
              | and_expression "&" equality_expression

equality_expression: relational_expression
                   | equality_expression "==" relational_expression
                   | equality_expression "!=" relational_expression

relational_expression: shift_expression
                     | relational_expression "<" shift_expression
                     | relational_expression ">" shift_expression
                     | relational_expression "<=" shift_expression
                     | relational_expression ">=" shift_expression

shift_expression: additive_expression
                | shift_expression "<<" additive_expression
                | shift_expression ">>" additive_expression

additive_expression: multiplicative_expression
                   | additive_expression "+" multiplicative_expression
                   | additive_expression "-" multiplicative_expression

multiplicative_expression: cast_expression
                         | multiplicative_expression "*" cast_expression
                         | multiplicative_expression "/" cast_expression
                         | multiplicative_expression "%" cast_expression

cast_expression: unary_expression
               | "(" type_name ")" cast_expression

unary_expression: postfix_expression
                | "++" unary_expression
                | "--" unary_expression
                | unary_operator cast_expression
                | "sizeof" unary_expression
                | "sizeof" "(" type_name ")"

unary_operator: "&" | "*" | "+" | "-" | "~" | "!"

postfix_expression: primary_expression
                  | postfix_expression "[" expression "]"
                  | postfix_expression "(" argument_expression_list? ")"
                  | postfix_expression "." identifier
                  | postfix_expression "->" identifier
                  | postfix_expression "++"
                  | postfix_expression "--"
                  | "(" type_name ")" "{" initializer_list "}" 
                  | "(" type_name ")" "{" initializer_list "," "}"

primary_expression: identifier
                  | constant
                  | string_literal+
                  | "(" expression ")"
                  | "(" compound_statement ")"
                  | generic_selection

generic_selection: "_Generic" "(" assignment_expression "," generic_assoc_list ")"

generic_assoc_list: generic_association ("," generic_association)*

generic_association: type_name ":" assignment_expression
                   | "default" ":" assignment_expression

argument_expression_list: argument ("," argument)*
argument: assignment_expression | type_name

constant: integer_constant
        | float_constant
        | char_constant

// Tokens and basic types
identifier: CNAME
string_literal.2: /(L|u|U|u8)?"([^"\\]*(\\.[^"\\]*)*)"/
integer_constant.2: /((0x[0-9a-fA-F]+)|([0-9]+))([uU]|[lL]|ll|LL|[uU][lL]|[lL][uU])?/
float_constant.2: /([0-9]*\.[0-9]+|[0-9]+\.)([eE][-+]?[0-9]+)?[fFlL]?/ | /[0-9]+[eE][-+]?[0-9]+[fFlL]?/
char_constant.2: /(L|u|U)?'([^'\\]*(\\.[^'\\]*)*)'/
typedef_name: identifier
constant_expression: conditional_expression

%import common.CNAME
%import common.WS
%import common.CPP_COMMENT
%import common.C_COMMENT
%ignore WS
%ignore CPP_COMMENT
%ignore C_COMMENT
